-- ===================================
-- GOAL PARK DATABASE SCHEMA
-- สร้างฐานข้อมูลใหม่ตามโครงสร้างที่กำหนด
-- ===================================

-- ลบตารางเก่าทั้งหมด (ถ้ามี)
DROP TABLE IF EXISTS payment_slips CASCADE;
DROP TABLE IF EXISTS bookings CASCADE;
DROP TABLE IF EXISTS user_sessions CASCADE;
DROP TABLE IF EXISTS profiles CASCADE;
DROP TABLE IF EXISTS stadiums CASCADE;
DROP TABLE IF EXISTS users CASCADE;

-- ลบ Functions และ Triggers เก่า
DROP FUNCTION IF EXISTS notify_booking_to_make(jsonb) CASCADE;
DROP FUNCTION IF EXISTS trigger_booking_notification() CASCADE;
DROP FUNCTION IF EXISTS test_make_webhook(text) CASCADE;
DROP FUNCTION IF EXISTS get_admin_dashboard_stats() CASCADE;
DROP FUNCTION IF EXISTS admin_approve_booking(uuid, text) CASCADE;
DROP FUNCTION IF EXISTS admin_reject_booking(uuid, text) CASCADE;
DROP FUNCTION IF EXISTS update_updated_at_column() CASCADE;
DROP FUNCTION IF EXISTS check_booking_conflict(text,date,time without time zone,time without time zone,uuid) CASCADE;
DROP FUNCTION IF EXISTS check_booking_conflict(uuid,date,time without time zone,time without time zone,uuid) CASCADE;

-- ===================================
-- 1. สร้างตาราง STADIUMS
-- ===================================
CREATE TABLE stadiums (
    id INT4 PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name TEXT NOT NULL,
    address TEXT,
    price_per_hour NUMERIC,
    description TEXT,
    image_url TEXT,
    facilities TEXT,
    status TEXT DEFAULT 'active',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- เพิ่มข้อมูลสนามเริ่มต้น
INSERT INTO stadiums (name, address, price_per_hour, description, facilities, status) VALUES
('The jaguar Maejo stadium', 'มหาวิทยาลัยแม่โจ้ จ.เชียงใหม่', 500, 'สนามฟุตบอลหญ้าธรรมชาติคุณภาพสูง', 'สนามหญ้า, ไฟส่องสว่าง, ที่จอดรถ, ห้องแต่งตัว', 'active'),
('Maejo Arena', 'มหาวิทยาลัยแม่โจ้ จ.เชียงใหม่', 800, 'สนามฟุตบอลในร่มพร้อมระบบปรับอากาศ', 'สนามในร่ม, แอร์, ห้องแต่งตัว, ระบบเสียง', 'active'),
('สนามฟุตบอล รวมโชค สปอร์ตคลับ', 'ต.สันทราย อ.สันทราย จ.เชียงใหม่', 400, 'สนามฟุตบอลหญ้าเทียมมาตรฐาน', 'หญ้าเทียม, ไฟส่องสว่าง, ที่จอดรถ', 'active');

-- ===================================
-- 2. สร้างตาราง BOOKINGS
-- ===================================
CREATE TABLE bookings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID,
    stadium_name TEXT NOT NULL,
    stadium_address TEXT,
    booker_name TEXT NOT NULL,
    booker_phone TEXT,
    booker_email TEXT,
    booking_date DATE NOT NULL,
    start_time TIME NOT NULL,
    end_time TIME NOT NULL,
    duration INT4,
    price_per_hour NUMERIC,
    total_price NUMERIC,
    payment_slip_url TEXT,
    payment_slip_filename TEXT,
    admin_notes TEXT,
    notes TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    status VARCHAR DEFAULT 'pending_payment',
    payment_status VARCHAR DEFAULT 'pending',
    
    -- ข้อจำกัดเพื่อป้องกันเวลาไม่ถูกต้อง
    CONSTRAINT valid_time_range CHECK (start_time < end_time),
    CONSTRAINT valid_booking_date CHECK (booking_date >= CURRENT_DATE)
);

-- สร้าง Function เพื่อตรวจสอบการทับซ้อนของเวลา (ใช้กับระบบเดิม)
CREATE OR REPLACE FUNCTION prevent_booking_overlap()
RETURNS TRIGGER AS $$
BEGIN
    -- ตรวจสอบการจองซ้ำก่อนทำการ INSERT หรือ UPDATE
    IF EXISTS (
        SELECT 1 FROM bookings 
        WHERE stadium_name = NEW.stadium_name
          AND booking_date = NEW.booking_date
          AND status NOT IN ('cancelled', 'no_show', 'rejected')
          AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::UUID)
          AND (
              -- ตรวจสอบการทับซ้อนของเวลา
              (NEW.start_time < end_time AND NEW.end_time > start_time) OR
              (NEW.start_time >= start_time AND NEW.end_time <= end_time) OR
              (start_time >= NEW.start_time AND end_time <= NEW.end_time) OR
              (NEW.start_time = start_time OR NEW.end_time = end_time)
          )
    ) THEN
        RAISE EXCEPTION 'มีการจองซ้ำในช่วงเวลานี้แล้ว สนาม: %, วันที่: %, เวลา: % - %', 
            NEW.stadium_name, NEW.booking_date, NEW.start_time, NEW.end_time;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- สร้าง Trigger เพื่อเรียกใช้ Function
CREATE TRIGGER trigger_prevent_booking_overlap
    BEFORE INSERT OR UPDATE ON bookings
    FOR EACH ROW
    EXECUTE FUNCTION prevent_booking_overlap();

-- ===================================
-- 3. สร้างตาราง PROFILES
-- ===================================
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT,
    full_name TEXT,
    phone TEXT,
    role TEXT DEFAULT 'user',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- เพิ่ม Foreign Key Constraints หลังจากสร้างตารางทั้งหมดแล้ว
ALTER TABLE bookings 
ADD CONSTRAINT fk_bookings_user_id 
FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE SET NULL;

-- ===================================
-- 4. สร้าง INDEXES สำหรับประสิทธิภาพ
-- ===================================

-- Stadium indexes
CREATE INDEX idx_stadiums_name ON stadiums(name);
CREATE INDEX idx_stadiums_status ON stadiums(status);

-- Booking indexes
CREATE INDEX idx_bookings_date ON bookings(booking_date);
CREATE INDEX idx_bookings_stadium_name ON bookings(stadium_name);
CREATE INDEX idx_bookings_user ON bookings(user_id);
CREATE INDEX idx_bookings_status ON bookings(status);
CREATE INDEX idx_bookings_payment_status ON bookings(payment_status);
CREATE INDEX idx_bookings_datetime ON bookings(booking_date, start_time, end_time);

-- Profile indexes
CREATE INDEX idx_profiles_email ON profiles(email);
CREATE INDEX idx_profiles_role ON profiles(role);

-- ===================================
-- 5. สร้าง TRIGGERS สำหรับ updated_at
-- ===================================

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Apply triggers
CREATE TRIGGER update_stadiums_updated_at BEFORE UPDATE ON stadiums
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_bookings_updated_at BEFORE UPDATE ON bookings
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON profiles
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ===================================
-- สร้าง Function และ Trigger สำหรับ Auto-create Profile
-- ===================================

-- Function สำหรับสร้าง profile อัตโนมัติเมื่อมี user ใหม่
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, email, full_name)
    VALUES (
        NEW.id,
        NEW.email,
        COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.email)
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger ที่เรียกใช้เมื่อมี user ใหม่ใน auth.users
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION handle_new_user();

-- ===================================
-- 6. สร้าง RLS POLICIES
-- ===================================

-- Enable RLS
ALTER TABLE stadiums ENABLE ROW LEVEL SECURITY;
ALTER TABLE bookings ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- Stadium policies (อ่านได้ทุกคน)
CREATE POLICY "Everyone can view stadiums" ON stadiums
    FOR SELECT USING (true);

CREATE POLICY "Admin can manage stadiums" ON stadiums
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE profiles.id = auth.uid() 
            AND profiles.role = 'admin'
        )
    );

-- Booking policies
CREATE POLICY "Users can view their own bookings" ON bookings
    FOR SELECT USING (
        user_id = auth.uid() OR 
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE profiles.id = auth.uid() 
            AND profiles.role IN ('admin', 'staff')
        )
    );

CREATE POLICY "Anyone can create bookings" ON bookings
    FOR INSERT WITH CHECK (true);

CREATE POLICY "Users can update their own bookings" ON bookings
    FOR UPDATE USING (
        user_id = auth.uid() OR 
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE profiles.id = auth.uid() 
            AND profiles.role IN ('admin', 'staff')
        )
    );

-- Profile policies
CREATE POLICY "Users can view their own profile" ON profiles
    FOR ALL USING (id = auth.uid());

-- ===================================
-- 7. สร้าง FUNCTIONS สำหรับการจัดการ
-- ===================================

-- Function: ตรวจสอบการจองซ้ำ (ปรับปรุงให้ใช้กับระบบเดิม)
CREATE OR REPLACE FUNCTION check_booking_conflict(
    p_stadium_name TEXT,
    p_booking_date DATE,
    p_start_time TIME,
    p_end_time TIME,
    p_exclude_booking_id UUID DEFAULT NULL
)
RETURNS TABLE(
    has_conflict BOOLEAN,
    conflicting_bookings JSON
) AS $$
DECLARE
    conflict_count INTEGER;
    conflicts JSON;
BEGIN
    -- ตรวจสอบการจองซ้ำที่เข้มงวดขึ้น
    SELECT COUNT(*), 
           COALESCE(JSON_AGG(
               JSON_BUILD_OBJECT(
                   'id', id,
                   'booker_name', booker_name,
                   'start_time', start_time,
                   'end_time', end_time,
                   'status', status,
                   'booking_date', booking_date
               )
           ), '[]'::JSON)
    INTO conflict_count, conflicts
    FROM bookings
    WHERE stadium_name = p_stadium_name
      AND booking_date = p_booking_date
      AND status NOT IN ('cancelled', 'no_show', 'rejected')
      AND (
          -- กรณีที่ 1: เวลาใหม่เริ่มก่อนเวลาเดิมสิ้นสุด และ สิ้นสุดหลังเวลาเดิมเริ่ม
          (p_start_time < end_time AND p_end_time > start_time) OR
          -- กรณีที่ 2: เวลาใหม่อยู่ภายในเวลาเดิม
          (p_start_time >= start_time AND p_end_time <= end_time) OR
          -- กรณีที่ 3: เวลาเดิมอยู่ภายในเวลาใหม่
          (start_time >= p_start_time AND end_time <= p_end_time) OR
          -- กรณีที่ 4: เวลาเริ่มเท่ากัน หรือ เวลาสิ้นสุดเท่ากัน
          (p_start_time = start_time OR p_end_time = end_time)
      )
      AND (p_exclude_booking_id IS NULL OR id != p_exclude_booking_id);

    RETURN QUERY SELECT 
        (conflict_count > 0)::BOOLEAN,
        conflicts;
END;
$$ LANGUAGE plpgsql;

-- Function: สถิติ Dashboard
CREATE OR REPLACE FUNCTION get_admin_dashboard_stats()
RETURNS JSON AS $$
DECLARE
    result JSON;
BEGIN
    SELECT JSON_BUILD_OBJECT(
        'today_bookings', (
            SELECT COUNT(*) FROM bookings 
            WHERE booking_date = CURRENT_DATE
        ),
        'pending_payments', (
            SELECT COUNT(*) FROM bookings 
            WHERE status = 'pending_payment'
        ),
        'confirmed_bookings', (
            SELECT COUNT(*) FROM bookings 
            WHERE status = 'confirmed'
        ),
        'total_revenue_today', (
            SELECT COALESCE(SUM(total_price), 0) FROM bookings 
            WHERE booking_date = CURRENT_DATE 
            AND payment_status = 'paid'
        ),
        'total_revenue_month', (
            SELECT COALESCE(SUM(total_price), 0) FROM bookings 
            WHERE DATE_TRUNC('month', booking_date) = DATE_TRUNC('month', CURRENT_DATE)
            AND payment_status = 'paid'
        )
    ) INTO result;
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Function: อนุมัติการจอง
CREATE OR REPLACE FUNCTION admin_approve_booking(
    p_booking_id UUID,
    p_admin_notes TEXT DEFAULT ''
)
RETURNS JSON AS $$
DECLARE
    result JSON;
BEGIN
    UPDATE bookings 
    SET status = 'confirmed',
        payment_status = 'paid',
        admin_notes = p_admin_notes,
        updated_at = NOW()
    WHERE id = p_booking_id;
    
    SELECT JSON_BUILD_OBJECT(
        'success', true,
        'message', 'อนุมัติการจองเรียบร้อย'
    ) INTO result;
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Function: ปฏิเสธการจอง
CREATE OR REPLACE FUNCTION admin_reject_booking(
    p_booking_id UUID,
    p_admin_notes TEXT
)
RETURNS JSON AS $$
DECLARE
    result JSON;
BEGIN
    UPDATE bookings 
    SET status = 'cancelled',
        admin_notes = p_admin_notes,
        updated_at = NOW()
    WHERE id = p_booking_id;
    
    SELECT JSON_BUILD_OBJECT(
        'success', true,
        'message', 'ปฏิเสธการจองเรียบร้อย'
    ) INTO result;
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- ===================================
-- 8. GRANT PERMISSIONS
-- ===================================

-- Grant execute permissions on functions
GRANT EXECUTE ON FUNCTION check_booking_conflict(TEXT, DATE, TIME, TIME, UUID) TO authenticated, anon;
GRANT EXECUTE ON FUNCTION get_admin_dashboard_stats() TO authenticated;
GRANT EXECUTE ON FUNCTION admin_approve_booking(UUID, TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION admin_reject_booking(UUID, TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION handle_new_user() TO authenticated;

-- ===================================
-- 9. เพิ่มข้อมูลทดสอบ (ถ้าต้องการ)
-- ===================================

-- เพิ่ม Admin Profile (ใส่ UUID จริงจาก Supabase Auth)
-- INSERT INTO profiles (id, email, full_name, role) 
-- VALUES ('YOUR-AUTH-USER-ID', 'admin@goalpark.com', 'Admin User', 'admin');

-- ===================================
-- สิ้นสุดการสร้าง Database Schema
-- ===================================

-- ตรวจสอบการสร้างตาราง
SELECT 
    table_name,
    table_type
FROM information_schema.tables 
WHERE table_schema = 'public' 
    AND table_name IN ('stadiums', 'bookings', 'profiles')
ORDER BY table_name;